"use strict";(self.webpackChunkml_4_sim=self.webpackChunkml_4_sim||[]).push([[31],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return d}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var m=i.createContext({}),p=function(e){var t=i.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=p(e.components);return i.createElement(m.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,m=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=a,f=c["".concat(m,".").concat(d)]||c[d]||u[d]||r;return n?i.createElement(f,o(o({ref:t},s),{},{components:n})):i.createElement(f,o({ref:t},s))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7965:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return m},metadata:function(){return p},toc:function(){return s},default:function(){return c}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],l={sidebar_position:3},m="Inference optimization",p={unversionedId:"G4_Inference/inference_optimization",id:"G4_Inference/inference_optimization",title:"Inference optimization",description:"One of the figures of merit for selecting the best performing ML fast simulation model is the one with the best accuray while keeping the memory footprint as small as possible. Advances in memory optimization techniques allow the task of inference to have a small memory footprint. Employing these techniques can result in few factors of smaller memory footprint than a non optimzed model.",source:"@site/docs/G4_Inference/inference_optimization.md",sourceDirName:"G4_Inference",slug:"/G4_Inference/inference_optimization",permalink:"/docs/G4_Inference/inference_optimization",editUrl:"https://github.com/DalilaSalamani/ML4Sim_Documentation.git/docs/G4_Inference/inference_optimization.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Geant4 examples",permalink:"/docs/G4_Inference/G4_examples"}},s=[{value:"Optimization with ONNXRuntime",id:"optimization-with-onnxruntime",children:[{value:"Graph optimization in ONNXRuntime",id:"graph-optimization-in-onnxruntime",children:[],level:3},{value:"Quantization in ONNX Runtime",id:"quantization-in-onnx-runtime",children:[],level:3},{value:"Model profiling",id:"model-profiling",children:[],level:3}],level:2}],u={toc:s};function c(e){var t=e.components,l=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"inference-optimization"},"Inference optimization"),(0,r.kt)("p",null,"One of the figures of merit for selecting the best performing ML fast simulation model is the one with the best accuray while keeping the memory footprint as small as possible. Advances in memory optimization techniques allow the task of inference to have a small memory footprint. Employing these techniques can result in few factors of smaller memory footprint than a non optimzed model."),(0,r.kt)("h2",{id:"optimization-with-onnxruntime"},"Optimization with ONNXRuntime"),(0,r.kt)("h3",{id:"graph-optimization-in-onnxruntime"},"Graph optimization in ONNXRuntime"),(0,r.kt)("p",null,"Graph optimizations are graph-level transformations. ONNXRuntime provides various graph optimizations to improve model performance.Among those: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Basic Graph Optimizations : which perform a removal of redundant nodes and redundant computations"),(0,r.kt)("li",{parentName:"ul"},"Extended Graph Optimizations: which fuse nodes")),(0,r.kt)("p",null,"Graph optimizations can be performed either in:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Online mode: where the optimizations are done before the inference. "),(0,r.kt)("li",{parentName:"ul"},"Offline mode: the runtime saves the optimized graph to disk. ")),(0,r.kt)("p",null,"ONNX Runtime provides Python, C#, C++, and C APIs to enable different optimization levels and to choose between offline vs. online mode."),(0,r.kt)("h3",{id:"quantization-in-onnx-runtime"},"Quantization in ONNX Runtime"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://onnxruntime.ai/docs/performance/quantization.html"},"Quantization in ONNX Runtime")," refers to 8 bit linear quantization. Floating point real values are mapped to an 8 bit quantization space."),(0,r.kt)("p",null,"The table below shows the disk space and the memory footprint of the model using the quantization."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Raw model"),(0,r.kt)("th",{parentName:"tr",align:null},"Quantized model"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Disk space (MB)"),(0,r.kt)("td",{parentName:"tr",align:null},"551"),(0,r.kt)("td",{parentName:"tr",align:null},"139")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Resident memory (MB)"),(0,r.kt)("td",{parentName:"tr",align:null},"2265.34"),(0,r.kt)("td",{parentName:"tr",align:null},"650.414")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Virtual memory(MB)"),(0,r.kt)("td",{parentName:"tr",align:null},"3205.26"),(0,r.kt)("td",{parentName:"tr",align:null},"1339.22")))),(0,r.kt)("p",null,"Graph optimization of a quantized model in an online mode would give:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Basic optimization"),(0,r.kt)("th",{parentName:"tr",align:null},"Extended mooptimizationdel"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Resident memory (MB)"),(0,r.kt)("td",{parentName:"tr",align:null},"650.414"),(0,r.kt)("td",{parentName:"tr",align:null},"555.828")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Virtual memory (MB)"),(0,r.kt)("td",{parentName:"tr",align:null},"1339.22"),(0,r.kt)("td",{parentName:"tr",align:null},"1073.21")))),(0,r.kt)("h3",{id:"model-profiling"},"Model profiling"),(0,r.kt)("p",null,"Using ONNXRuntime, we can enable model execution profiling by setting this in the inference session options. This saves a JSON file which can be used by trace event profiling tools such as chrome for tracing, in order to analyze the execution for example to refine and check time and effect of sequential or parallel execution."),(0,r.kt)("p",null,"The image below shows the execution profile of running a single shower simulation event. We can see there are three sequential steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Model loading"),(0,r.kt)("li",{parentName:"ul"},"Session initialization : doing graph optim exe when the model is loaded"),(0,r.kt)("li",{parentName:"ul"},"Inference running  ")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(6533).Z,width:"1990",height:"254"})),(0,r.kt)("p",null,"If we zoom into the inference running, we can see the model run time, the sequential executtor and all the set of operations used by the model such as the ",(0,r.kt)("strong",{parentName:"p"},"Relu")," activation function (red circle), where the tool can provide us more information such as the wall duration (0.007ms) and the provider which is a CPU executor."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(7114).Z,width:"1758",height:"794"})),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Sequential executor ")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"This means that the graph is not solved in a parallel way but sequentially "))),(0,r.kt)("p",null,"To read more:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Graph Optimizations in ONNX Runtime, ",(0,r.kt)("a",{parentName:"li",href:"https://onnxruntime.ai/docs/performance/graph-optimizations.html"},"URL"))))}c.isMDXComponent=!0},6533:function(e,t,n){t.Z=n.p+"assets/images/ONNX_Profile_1-a966a8eba00f9ce2292ff03bedc542c2.png"},7114:function(e,t,n){t.Z=n.p+"assets/images/ONNX_Profile_2-2c12f324c24a5528fc630f27452b7df7.png"}}]);